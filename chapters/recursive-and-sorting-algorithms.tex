\chapter{Recursive and Sorting Algorithms}

\section{Recursion}

Recursion is when a function calls itself.

\subsection{Linear Recursion}

Linear recursion is when a function calls a single recursive call.

\subsection{Tail Recursion}

Tail recursion is when a function calls a recursive call as the last step.

\subsection{Binary Recursion}

Binary recursion is when a function calls two recursive calls.

\subsection{Multiple Recursion}

Multiple recursion is when a function calls multiple recursive calls.

\subsection{Base Case}

The condition where the function stops calling itself.

\subsection{Recursive Case}

The condition where the function calls itself.

\section{Divide and Conquer Algorithms}

Divide and conquer algorithms is an algorithm that divide (break the problem into subproblems), conquer (solves the subproblems) and combine (merge the solutions to the subproblems to solve the problem). These algorithms include: binary search, merge sort and quick sort.

\section{Search Algorithms}

A search algorithm is an algorithm used to find an item from a collection items.

\subsection{Linear Search}

A linear search is a search algorithm used to find an item by checking a collection of items one by one.

Time Complexity: $O(n)$

\subsection{Binary Search}

A binary search is a search algorithm used to find an item by checking halves of a sorted collection of items.

Time Complexity: $O(\log_{2}(n))$

\section{Sorting Algorithms}

A sorting algorithm is an algorithm used to sort a collection of items.

\subsection{Selection Sort}

Selection sort is a sorting algorithm that repeatedly finds the smallest (or greatest) item from the unsorted part of the collection and swaps it with the first item in the unsorted part of the collection until the collection is sorted.

Time Complexity:

\begin{itemize}
  \item Best-case: $O(n^2)$
  \item Average-case: $O(n^2)$
  \item Worst-case: $O(n^2)$
\end{itemize}

Space-Complexity:

\begin{itemize}
  \item In-place: $O(1)$
\end{itemize}

\subsection{Insertion Sort}

Insertion sort is a sorting algorithm that repeatedly gets the first item in the unsorted collection and finds and inserts it into the correct position in the sorted part of the collection until the collection is sorted.

Time Complexity:

\begin{itemize}
  \item Best-case: $O(n)$
  \item Average-case: $O(n^2)$
  \item Worst-case: $O(n^2)$
\end{itemize}

Space Complexity:

\begin{itemize}
  \item In-place: $O(1)$
  \item Not in-place: $O(n)$
\end{itemize}

\subsection{Merge Sort}

Merge sort is a sorting algorithm that recursively splits a collection into halves, sorts each half, and merges them back until the collection is sorted.

Time Complexity: 

\begin{itemize}
  \item Best-case: $O(n\log_{2}n)$
  \item Average-case: $O(n\log_{2}n)$
  \item Worst-case: $O(n\log_{2}n)$
\end{itemize}

Space Complexity:

\begin{itemize}
  \item Not in-place: $O(n)$
\end{itemize}

\subsection{Quick Sort}

Quick sort is a sorting algorithm that recursively partitions a collection around a random pivot where left side is less than pivot and right side is greater than pivot until the collection is sorted.

Time Complexity:

\begin{itemize}
  \item Best-case: $O(n\log_{2}(n))$
  \item Average-case: $O(n\log_{2}(n))$
  \item Worst-case: $O(n^{2})$
\end{itemize}

Space Complexity:

\begin{itemize}
  \item In-place: $O(\log_{2}(n))$
  \item Not in-place: $O(n)$
\end{itemize}

\section{Problems}

\section{Solutions}
